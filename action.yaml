---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# promote-draft-release-action
name: 'â« Promote Draft Release'
description: 'Promotes a draft GitHub release to a full release'
# When no inputs specified, defaults to most recent draft release

inputs:
  # Mandatory
  token:
    description: 'GitHub Token with write content permissions'
    required: true
    type: 'string'
  # Optional
  latest:
    description: 'Mark as the latest release'
    required: false
    default: false
    type: 'boolean'
  tag:
    description: 'Tag of draft release to promote'
    required: false
    type: 'string'
  name:
    description: 'Name of draft release to promote'
    required: false
    type: 'string'
  sort_by:
    description: 'Sort releases by this field'
    required: false
    type: 'string'
    default: 'none'
  sort_reverse:
    # Note: reversal performed after sort_by operations
    description: 'Reverse sorting order'
    required: false
    type: 'boolean'
    default: false
  dry-run:
    description: 'Perform validation without promoting the release'
    required: false
    type: 'boolean'
    default: false

outputs:
  release_url:
    description: 'URL to the newly promoted release'
    value: "${{ steps.promote-draft-release.outputs.release_url }}"

runs:
  using: 'composite'
  steps:
    - name: 'Capture draft releases in repository'
      id: promote-draft-release
      env:
        GITHUB_TOKEN: "${{ inputs.token }}"
      shell: bash
      # yamllint disable rule:line-length
      run: |
        # Capture draft releases in repository

        tag="${{ inputs.tag }}"
        name="${{ inputs.name }}"
        sort_by="${{ inputs.sort_by }}"
        sort_reverse="${{ inputs.sort_reverse }}"
        dry_run="${{ inputs.dry-run }}"

        # Validate prerequisites
        if [ -z "$GITHUB_TOKEN" ]; then
          echo 'Error: GitHub token not passed to action âŒ'
          exit 1
        fi

        if ! command -v jq &> /dev/null; then
          echo 'Error: jq command not found âŒ'
          exit 1
        fi

        # Get all releases
        release_data=$(gh release list --json createdAt,isDraft,isLatest,isPrerelease,name,publishedAt,tagName)
        [ -z "$release_data" ] && { echo 'Error: No releases found âŒ'; exit 1; }
        [ "$ACTIONS_STEP_DEBUG" = 'true' ] && echo "Raw data: $release_data"

        # Ensure data is an array
        echo "$release_data" | jq -e 'type == "array"' > /dev/null 2>&1 || release_data=$(echo "$release_data" | jq -s '.')

        # Filter to drafts only
        drafts_only=$(echo "$release_data" | jq '[.[] | select(.isDraft==true)]')
        draft_count=$(echo "$drafts_only" | jq 'length')
        [ "$draft_count" -eq 0 ] && { echo 'Error: No draft releases found âŒ'; exit 1; }

        # Apply sorting
        if [ "$sort_by" != 'none' ]; then
          # Validate sort_by field
          valid_fields="createdAt isDraft isLatest isPrerelease name publishedAt tagName"
          if echo "$valid_fields" | grep -qw "$sort_by"; then
            drafts_only=$(echo "$drafts_only" | jq --arg field "$sort_by" 'sort_by(.[$field])')
          else
            echo "Error: Invalid sort_by field '$sort_by' âŒ"
            echo "  Valid fields: $valid_fields"
            exit 1
          fi
        fi
        [ "$sort_reverse" = 'true' ] && drafts_only=$(echo "$drafts_only" | jq 'reverse')

        # Filter by tag/name
        selected_release="$drafts_only"
        [ -n "$tag" ] && selected_release=$(echo "$selected_release" | jq --arg tag "$tag" '[.[] | select(.tagName==$tag)]')
        [ -n "$name" ] && selected_release=$(echo "$selected_release" | jq --arg name "$name" '[.[] | select(.name==$name)]')

        # Validate match
        matching_count=$(echo "$selected_release" | jq 'length')
        if [ "$matching_count" -eq 0 ]; then
          echo 'Error: No draft release matches the specified criteria âŒ'
          [ -n "$tag" ] && echo "  Tag: $tag"
          [ -n "$name" ] && echo "  Name: $name"
          exit 1
        fi

        # Get first match
        selected_release=$(echo "$selected_release" | jq '.[0]')
        tagName=$(echo "$selected_release" | jq -r '.tagName')

        # Warn about other drafts
        if [ "$draft_count" -gt 1 ]; then
          other_drafts=$(echo "$drafts_only" | jq --arg tag "$tagName" -r '[.[] | select(.tagName != $tag) | .tagName] | join(", ")')
          if [ -n "$other_drafts" ]; then
            echo "::warning::Non-matching draft releases found: $other_drafts"
            echo "âš ï¸  Other drafts: $other_drafts" >> "$GITHUB_STEP_SUMMARY"
          fi
        fi

        # Promote or dry-run
        if [ "$dry_run" = 'true' ]; then
          # URL encode the tag name for dry-run URL construction
          encoded_tag=$(printf %s "$tagName" | jq -sRr @uri)
          release_url="https://github.com/${{ github.repository }}/releases/tag/$encoded_tag"
          if [ "${{ inputs.latest }}" = 'true' ]; then
            echo "Dry-run: Would promote $tagName and set as latest"
            echo "## ðŸ” Dry Run: $tagName" >> "$GITHUB_STEP_SUMMARY"
            echo "Would promote to latest release" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "Dry-run: Would promote $tagName"
            echo "## ðŸ” Dry Run: $tagName" >> "$GITHUB_STEP_SUMMARY"
            echo "Would promote to release" >> "$GITHUB_STEP_SUMMARY"
          fi
        else
          # Promote the release (gh release edit doesn't return URL)
          if [ "${{ inputs.latest }}" = 'true' ]; then
            gh release edit "$tagName" --draft=false --latest
          else
            gh release edit "$tagName" --draft=false
          fi

          # Construct the release URL
          encoded_tag=$(printf %s "$tagName" | jq -sRr @uri)
          release_url="https://github.com/${{ github.repository }}/releases/tag/$encoded_tag"
          echo "Promoted: $release_url âœ…"
          echo "## â« Promoted: $tagName" >> "$GITHUB_STEP_SUMMARY"
          echo "$release_url" >> "$GITHUB_STEP_SUMMARY"
        fi

        # Set outputs
        echo "release_url=$release_url" >> "$GITHUB_ENV"
        echo "release_url=$release_url" >> "$GITHUB_OUTPUT"
